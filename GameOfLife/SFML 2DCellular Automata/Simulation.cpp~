#include "Simulation.h"


void Simulation::initVars()
{
    this->window = nullptr;
    this->LiveCells = 0;
    this->DeadCells = 0;    
}

void Simulation::initWindow()
{
  this->videoMode.height = 100;
  this->videoMode.width = 100;
  
  this->window = new sf::RenderWindow(this->videoMode, "Cellular Automata", sf::Style::Titlebar | sf::Style::Close);
  this->window->setFramerateLimit(144);
}

void Simulation::initCells()
{
  std::vector<sf::RectangleShape> c;
  this->Cells = c;
  
  for(int i=0; i < this->videoMode.height; i++){
    for(int j=0; j < this->videoMode.width; j++){
      
      sf::RectangleShape cell;

      cell.setPosition(i,j);
      cell.setSize(sf::Vector2f(1.f,1.f));

      if (rand() % 10 < 4){
	cell.setFillColor(sf::Color::White);
      }
      else{
	cell.setFillColor(sf::Color::Black);
      }
      //cell.setOutlineColor(sf::Color::White);
      //cell.setOutlineThickness(1.f);

      this->Cells.push_back( cell );
    }
  }
}

// Con-/De- structors
Simulation::Simulation()
{
  this->initVars();
  this->initWindow();
  this->initCells();
}

Simulation::~Simulation()
{
  delete this->window;  // prevent memory leaks
}

const bool Simulation::IsRunning() const
{
  return this->window->isOpen();
}

void Simulation::EventPoll()
{
  //Event polling
  while(this->window->pollEvent(this->event))
    {
      switch (this->event.type)
	{
	case sf::Event::Closed:
	  this->window->close();
	  break;
          
	case sf::Event::KeyPressed:
	  if(this->event.key.code == sf::Keyboard::Escape)
	    this->window->close();
	  else if(this->event.key.code == sf::Keyboard::G)
	    this->window->close();
	  break;
	}
    }
}

void Simulation::updateMousePos()
{
  this->mousePosWindow = sf::Mouse::getPosition(*this->window);
}

int Simulation::countNeighbors(int i, int j)
{

  int width = this->videoMode.width;
  std::vector<sf::RectangleShape> neighbors = {
    this->Cells[(i-1) + (j-1)*width],
    this->Cells[(i) + (j-1)*width],
    this->Cells[(i+1) + (j-1)*width],
    this->Cells[(i-1) + (j)*width],
    this->Cells[(i+1) + (j)*width],
    this->Cells[(i-1) + (j+1)*width],
    this->Cells[(i) + (j+1)*width],
    this->Cells[(i+1) + (j+1)*width]
  };
  
  int count = 0;
  
  for (auto& cell: neighbors)
  {    
    if(cell.getFillColor() == sf::Color::White)
    {
      count++;
    }
  }
  
  return count;
 
}

void Simulation::updateGrid()
{
  std::vector<sf::RectangleShape> newGrid = Cells;
  
  for(int i=1; i < this->videoMode.width - 1; i++)
  {
    for( int j=1; j < this->videoMode.height - 1; j++)
    {
      
      sf::Color c = Cells[i + j*width].getFillColor();
      int N = this->countNeighbors(i, j);

      if(c == sf::Color::White)
      {
	if(N<2 || N>3)
	{
	  newGrid[i + j*width].setFillColor(sf::Color::Black);
	}
      }
      else if(c == sf::Color::Black)
      {
	if (N==3)
	{
	  newGrid[i + j*width].setFillColor(sf::Color::Black);
	}	    
      } 
    }
  }
  this->Cells = newGrid;
  newGrid.clear();
}
 
// logic / functions / math / anything non-rendering
void Simulation::update()
{
  this->EventPoll();
  this->updateMousePos();
  this->updateGrid();
}

void Simulation::renderGrid()
{

  
  for(auto & cell: this->Cells)
  {
    //std::cout << '(' << cell.getPosition().x << ", " << cell.getPosition().y << ")\n";
    this->window->draw(cell);
  }
  
}

void Simulation::render()
{
  this->window->clear();  

  this->renderGrid();
  
  this->window->display();
}
